!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ARMGNU	Makefile	/^ARMGNU ?= aarch64-elf$/;"	m
ARM_LOCAL_BASE	src/drivers/gic.c	/^#define ARM_LOCAL_BASE /;"	d	file:
ASMFLAGS	Makefile	/^ASMFLAGS =$/;"	m
BUILD_DIR	Makefile	/^BUILD_DIR = build$/;"	m
CFLAGS	Makefile	/^CFLAGS = -Wall -O2 -ffreestanding -nostdinc -nostdlib -nostartfiles -mcpu=cortex-a72 -I$(INC_DIR)$/;"	m
CNTP_IRQ_ENABLE	src/drivers/gic.c	/^#define CNTP_IRQ_ENABLE /;"	d	file:
CONTEXT_FRAME_SIZE	src/drivers/task.c	/^#define CONTEXT_FRAME_SIZE /;"	d	file:
CORE0_IRQ_SOURCE	src/drivers/gic.c	/^#define CORE0_IRQ_SOURCE /;"	d	file:
CORE0_TIMER_IRQ_CTRL	src/drivers/gic.c	/^#define CORE0_TIMER_IRQ_CTRL /;"	d	file:
DRIVER_DIR	Makefile	/^DRIVER_DIR = $(SRC_DIR)\/drivers$/;"	m
ELF	Makefile	/^ELF = kernel8.elf$/;"	m
GICC_BASE	src/drivers/gic.c	/^#define GICC_BASE /;"	d	file:
GICC_CTLR	src/drivers/gic.c	/^#define GICC_CTLR /;"	d	file:
GICC_EOIR	src/drivers/gic.c	/^#define GICC_EOIR /;"	d	file:
GICC_IAR	src/drivers/gic.c	/^#define GICC_IAR /;"	d	file:
GICC_PMR	src/drivers/gic.c	/^#define GICC_PMR /;"	d	file:
GICD_BASE	src/drivers/gic.c	/^#define GICD_BASE /;"	d	file:
GICD_CTLR	src/drivers/gic.c	/^#define GICD_CTLR /;"	d	file:
GICD_IPRIORITYR	src/drivers/gic.c	/^#define GICD_IPRIORITYR /;"	d	file:
GICD_ISENABLER	src/drivers/gic.c	/^#define GICD_ISENABLER /;"	d	file:
GICD_ITARGETSR	src/drivers/gic.c	/^#define GICD_ITARGETSR /;"	d	file:
GIC_BASE	src/drivers/gic.c	/^#define GIC_BASE /;"	d	file:
GIC_H	include/gic.h	/^#define GIC_H$/;"	d
GPFSEL1	src/drivers/uart.c	/^#define GPFSEL1 /;"	d	file:
GPPUD	src/drivers/uart.c	/^#define GPPUD /;"	d	file:
GPPUDCLK0	src/drivers/uart.c	/^#define GPPUDCLK0 /;"	d	file:
INC_DIR	Makefile	/^INC_DIR = include$/;"	m
IRQ_SOURCE_CNTP	src/drivers/gic.c	/^#define IRQ_SOURCE_CNTP /;"	d	file:
MAX_TASKS	src/drivers/task.c	/^#define MAX_TASKS /;"	d	file:
MMIO_BASE	src/drivers/uart.c	/^#define MMIO_BASE /;"	d	file:
OBJS	Makefile	/^OBJS = $(BUILD_DIR)\/boot.o \\$/;"	m
SRC_DIR	Makefile	/^SRC_DIR = src$/;"	m
TARGET	Makefile	/^TARGET = kernel8.img$/;"	m
TASK_BLOCKED	include/task.h	/^    TASK_BLOCKED,$/;"	e	enum:__anon1
TASK_DEAD	include/task.h	/^    TASK_DEAD$/;"	e	enum:__anon1
TASK_H	include/task.h	/^#define TASK_H$/;"	d
TASK_READY	include/task.h	/^    TASK_READY,$/;"	e	enum:__anon1
TASK_RUNNING	include/task.h	/^    TASK_RUNNING,$/;"	e	enum:__anon1
TIMER_H	include/timer.h	/^#define TIMER_H$/;"	d
UART0_CR	src/drivers/uart.c	/^#define UART0_CR /;"	d	file:
UART0_DR	src/drivers/uart.c	/^#define UART0_DR /;"	d	file:
UART0_FBRD	src/drivers/uart.c	/^#define UART0_FBRD /;"	d	file:
UART0_FR	src/drivers/uart.c	/^#define UART0_FR /;"	d	file:
UART0_IBRD	src/drivers/uart.c	/^#define UART0_IBRD /;"	d	file:
UART0_ICR	src/drivers/uart.c	/^#define UART0_ICR /;"	d	file:
UART0_LCRH	src/drivers/uart.c	/^#define UART0_LCRH /;"	d	file:
UART_FR_RXFE	src/drivers/uart.c	/^#define UART_FR_RXFE /;"	d	file:
UART_FR_TXFF	src/drivers/uart.c	/^#define UART_FR_TXFF /;"	d	file:
UART_H	include/uart.h	/^#define UART_H$/;"	d
_start	src/boot.S	/^_start:$/;"	l
at_el1	src/boot.S	/^at_el1:$/;"	l
at_el2	src/boot.S	/^at_el2:$/;"	l
bss_clear_done	src/boot.S	/^bss_clear_done:$/;"	l
bss_clear_loop	src/boot.S	/^bss_clear_loop:$/;"	l
cpu_halt	src/boot.S	/^cpu_halt:$/;"	l
current_task	src/drivers/task.c	/^static task_t *current_task = 0;$/;"	v	file:
delay	src/drivers/uart.c	/^static void delay(unsigned int count) {$/;"	f	file:
dequeue_ready_task	src/drivers/task.c	/^static task_t *dequeue_ready_task(void) {$/;"	f	file:
enqueue_task	src/drivers/task.c	/^static void enqueue_task(task_t *task) {$/;"	f	file:
get_current_task	src/drivers/task.c	/^task_t *get_current_task(void) {$/;"	f
gic_enable_interrupt	src/drivers/gic.c	/^void gic_enable_interrupt(unsigned int int_id) {$/;"	f
gic_enable_timer_irq	src/drivers/gic.c	/^void gic_enable_timer_irq(void) {$/;"	f
gic_end_interrupt	src/drivers/gic.c	/^void gic_end_interrupt(unsigned int int_id) {$/;"	f
gic_get_interrupt	src/drivers/gic.c	/^unsigned int gic_get_interrupt(void) {$/;"	f
gic_init	src/drivers/gic.c	/^void gic_init(void) {$/;"	f
gic_timer_irq_pending	src/drivers/gic.c	/^int gic_timer_irq_pending(void) {$/;"	f
hang	src/vectors.S	/^hang:$/;"	l
id	include/task.h	/^    unsigned int id;$/;"	m	struct:task
idle_task	src/drivers/task.c	/^static void idle_task(void) {$/;"	f	file:
init_task_stack	src/drivers/task.c	/^static void init_task_stack(task_t *task, void (*entry_point)(void)) {$/;"	f	file:
irq_handler	src/kernel.c	/^void irq_handler(void) {$/;"	f
irq_handler_stub	src/vectors.S	/^irq_handler_stub:$/;"	l
kernel_main	src/kernel.c	/^void kernel_main(void) {$/;"	f
name	include/task.h	/^    char name[32];$/;"	m	struct:task
next	include/task.h	/^    struct task *next;          \/\/ Ready-queue link$/;"	m	struct:task	typeref:struct:task::task
next_task_id	src/drivers/task.c	/^static unsigned int next_task_id = 0;$/;"	v	file:
process_command	src/kernel.c	/^static void process_command(char *cmd) {$/;"	f	file:
ready_queue_head	src/drivers/task.c	/^static task_t *ready_queue_head = 0;$/;"	v	file:
schedule	src/drivers/task.c	/^void schedule(void) {$/;"	f
scheduler_init	src/drivers/task.c	/^void scheduler_init(void) {$/;"	f
sleep_until	include/task.h	/^    unsigned long sleep_until;  \/\/ Tick count to wake at$/;"	m	struct:task
sp	include/task.h	/^    unsigned long sp;           \/\/ Saved stack pointer$/;"	m	struct:task
stack	include/task.h	/^    unsigned long stack[1024];  \/\/ 8KB stack per task (1024 x 8 bytes)$/;"	m	struct:task
state	include/task.h	/^    task_state_t state;$/;"	m	struct:task
strcmp	src/kernel.c	/^static int strcmp(const char *s1, const char *s2) {$/;"	f	file:
strcpy_local	src/drivers/task.c	/^static void strcpy_local(char *dst, const char *src) {$/;"	f	file:
switch_to	src/context.S	/^switch_to:$/;"	l
task	include/task.h	/^typedef struct task {$/;"	s
task_create	src/drivers/task.c	/^void task_create(void (*entry_point)(void), const char *name) {$/;"	f
task_exit	src/drivers/task.c	/^void task_exit(void) {$/;"	f
task_pool	src/drivers/task.c	/^static task_t task_pool[MAX_TASKS];$/;"	v	file:
task_sleep	src/drivers/task.c	/^void task_sleep(unsigned int ms) {$/;"	f
task_state_t	include/task.h	/^} task_state_t;$/;"	t	typeref:enum:__anon1
task_t	include/task.h	/^} task_t;$/;"	t	typeref:struct:task
task_wrapper	src/drivers/task.c	/^static void task_wrapper(void) {$/;"	f	file:
task_yield	src/drivers/task.c	/^void task_yield(void) {$/;"	f
tick_count	src/drivers/timer.c	/^static volatile unsigned long tick_count = 0;$/;"	v	file:
timer_delay_ms	src/drivers/timer.c	/^void timer_delay_ms(unsigned int ms) {$/;"	f
timer_freq	src/drivers/timer.c	/^static unsigned long timer_freq = 0;$/;"	v	file:
timer_get_frequency	src/drivers/timer.c	/^unsigned long timer_get_frequency(void) {$/;"	f
timer_get_tick_count	src/drivers/timer.c	/^unsigned long timer_get_tick_count(void) {$/;"	f
timer_get_ticks	src/drivers/timer.c	/^unsigned long timer_get_ticks(void) {$/;"	f
timer_handle_irq	src/drivers/timer.c	/^void timer_handle_irq(void) {$/;"	f
timer_init	src/drivers/timer.c	/^void timer_init(unsigned int interval_ms) {$/;"	f
uart_getc	src/drivers/uart.c	/^unsigned char uart_getc(void) {$/;"	f
uart_getc_nonblock	src/drivers/uart.c	/^int uart_getc_nonblock(void) {$/;"	f
uart_gets	src/drivers/uart.c	/^void uart_gets(char* buffer, int max_len) {$/;"	f
uart_has_data	src/drivers/uart.c	/^int uart_has_data(void) {$/;"	f
uart_init	src/drivers/uart.c	/^void uart_init(void) {$/;"	f
uart_put_dec	src/drivers/uart.c	/^void uart_put_dec(unsigned long value) {$/;"	f
uart_put_hex	src/drivers/uart.c	/^void uart_put_hex(unsigned long value) {$/;"	f
uart_putc	src/drivers/uart.c	/^void uart_putc(unsigned char c) {$/;"	f
uart_puts	src/drivers/uart.c	/^void uart_puts(const char* str) {$/;"	f
vectors	src/vectors.S	/^vectors:$/;"	l
